SIMPLICITY IS GOOD!!!
* procedure to set up project
** backend  
  Start couch in a docker container
  bin/dcouch 
  open localhost:5984/_utils
  To tail the couch's log:
  docker-enter rcouch
  Then:
  tail -f /rel/rcouch/log/couch.log
  start backend:
  node backend/rean.js
  configure email and couch connection details in backend/env.js
  configure backend workers in backend/config.js
  
  reset couch with bin/dreset

* general programming concepts 
** defry, describe and delimit
*** don't ever fucking repeat your self!
   if yes -> refactor!! 
*** describe what you're doing, 
   clear logical flow, descriptive naming, choice comments, few or no corner case
   handling or out of place logic, explicitly type or make clear what variables
   are supposed to contain, use name params instead of list etc
*** delimit
break up in modules, pure/independant functions, not bigger than my head per
function, clear global structure/architecture
** modules with functions not objects with methods
** librairies not frameworks
** quotes
*** Dijkstra:
    Industry suffers from the managerial dogma that for the sake of stability
    and continuity, the company should be independent of the competence of
    individual employees.
    
** 12factor    
   I. Codebase
     One codebase tracked in revision control, many deploys
   II. Dependencies
     Explicitly declare and isolate dependencies
   III. Config
     Store config in the environment
     in env.js, this is hardcoded now, but will get from environment or from
     consul or other separate network?
   IV. Backing Services
     Treat backing services as attached resources
   V. Build, release, run
     Strictly separate build and run stages
   VI. Processes
   Execute the app as one or more stateless processes
     VII. Port binding
     Export services via port binding
   VIII. Concurrency
     Scale out via the process model
   IX. Disposability
     Maximize robustness with fast startup and graceful shutdown
   X. Dev/prod parity
     Keep development, staging, and production as similar as possible
   XI. Logs
     Treat logs as event streams
   XII. Admin processes
     Run admin/management tasks as one-off processes

* project concepts/design

** A user's doc stores his private data, such as app state, contact details etc. 
   If the user is actually a group, the group data is stored here.
** database per user.
Doubling as mailbox and data source for user.
Every user database is a set of docs that a user is allowed to see, a user can
also represent a group. 
Contents is controlled through:
1) vdu
2) Filtered replication
3) Periodic purge
   
Ways to limit excessive duplication:
1) Access attachments, binary files through a shared binary/attachment
   database, and using vdr on it to control access, when all that's stored in a
   database is text they maybe are not so big and can be duplicated for every user.
2) Upgrade a user's database to a group database, and share access to multiple
   users. In that case they all might need their own mailbox, either for
   private messages, or for duplicated user's customized access to another set
   up docs, possibly the private parts of the shared docs, linked to it by id.
3) Delete user and group databases when not accessed for a while. All data is in
   aggregate anyway and the only reason for these user and group databases to
   exist is to control and limit access to a certain subset of docs from this
   aggregate.
** a database can also be of the shared type
In this case the "user" has the name of the group. Docs in this database get
perhaps replicated to the aggregate, and have no access prop since they are not
shared any further, rather users have shared access to -it-. They can and should
be generated by the 'group' user, so all docs have as owner the 'group'. Or a
custom vdu can be put in place to sort on type for instance. 
The secObj.members.groups should be ["groupname"] so that users with that role
can access the database.
** sharing data
Two ways: either replicate and duplicate data to all users who have access
permissions, or move to separate database and set secObj.members.{roles|names}
to who you want to have access. The name should be guaranteed unique and
something like "shared_89334jkk8njfu83hfu3hf". This is created by sending a
message to cape who creates the database, changes the ownership? In any case
the data gets moved to the shared db and removed from the user's db.
** userids, roles and groups
- userids: Userid is always a user's email. His database is called:
  private_[email]_[md5hash-of-email] where email is normalized to only contain valid
  chars (only lowercase characters (a-z), digits (0-9), or any of the characters
  _, $, (, ), +, -, and / are allowed for database names). This way a user can
  deduce his private database from his email address, and it's unique, even
  across couchdb instances.
- Roles: Any roles a user has are the names other databases he can access. The
  goal is to not have any roles assigned since we hope not to have shared
  databases, but might have to do so to mitigate too much duplication.
- Groups: Users can also belong to groups. All user databases have a secObj. The
  only and necessary name added to members.names should be the users id, that
  is, his email address so that the user gets read access.
  
Members.roles of the user's databases lists the groups the user belongs to, this
is the same and should be synced with the groups property in the user's
doc. Each of these groups should start with an underscore in the secObj. Users
cannot be assigned roles that start with an underscore so this keeps the user's
database private. This way you can share docs with groups of users (enforced and
enabled with [vdu/filtered reps/purge].
** normalized 
Denormalize when convenient, but ultimately structure is defined by normalized
docs.
Views can be set up to fetch all relevant (joined) docs in one request. 
Validate Doc Read in rcouch doesn't work on views, so this necessitates
database per user. Vdr can be used other ways and in other places though. If
vdr is not available a proxy can be installed and configured
** generic doc structure:
   type: comment, article, product etc
   owner: id of creator/owner of doc
   last-modified
   last-modified-by
access: 
 selective replication, vdu and purge use this and the secObj of the database to
 decide what is allowed in the database.
 non-existent: 
All docs can have a access prop:
- non existent: only own  
** possible proxy need for:
- block _all_dbs
- alternative to vdr and rcouch:
  - block read on reception db
- disallow anonymous signup to couchdb

** Rebuild with just _users, aggregate, config.js, a couchdb instance and cape
This means you can delete private and shared databases when not needed or
accessed for a while. Users should send ping messages to keep a database alive,
because they can expire and would have to be rebuilt when a user log in again. 
* specs
** messages
***   Reception: 
- signup|forgotpwd|confirm
- mailbox? [username]
  if backend has forgot to setup user's mailbox, or it got wiped or whatever,
  client can send a msg with her username. Backend can then set up a mailbox and
  can send confirmation to public. Users' mailboxes are called mailbox_username
*** Mailbox:
- signedin
  This is instead of CouchDB session tracking, since I don't have access to
  it. Unless session tracker reads couch's log. 
  Message client can and should send after logging in, preferable with some uuid
  for the session. 
- loggingout
  Client should send this before explicitly logging out. But doesn't always
  happen, especially when connection breaks, or laptop gets closed, or cookie
  gets wiped etc.
- ping
  Client can send this when activity is detected so sessions can be better tracked
- database?
  Request for name(s) of database(s) client can use. By default a user's
  database is called db_username.
** client is totally independent from backend database and vice versa
   Niether should expect or demand anything from the other. Client should
   politely request for resources and if not granted solve its own problems.
   Backend workers though should do their best to accomodate and anticipate
   clients' needs, and organise things as best as they can.  This means keeping
   public, reception, postoffice and mailboxes in order, and any replications
   that are needed between them etc, and respond to client messages as well as possible.

** logging in and out
- on signup mailbox should have been made.
  if not or is deleted: 
  1) client can send msg to reception, 'mailbox?', confirm/error in
     public
  2) cape can check periodically and/or subscribe to db changes
- on login client should send msg to mailbox saying helloiam
- on logout should send msg 'goodbyefrom'.
  otherwise (reverse) proxy can maybe track login/logout?  or hack CouchDB,
  because couch doesn't tie sessions to users/logins unfortunately
  or client can logout msg when it can't read its own mailbox?

** client needs to update msg doc with "read=true" so backend can delete msg.
  backend still purges msg after a certain time. In case of public database
  user can only update existing msg doc (enforced by vdu). Same with msg
  written to mailbox or personal database.
    

*** 
* arguments for and against
** use separate databases reception and public
  semi public such as reception (wo) and public (ro) should not be merged with
  private databases in case the read and write validate and security objects
  are not configured properly, by accident or bugs or whatever. Better to keep
  separate for security reasons, but in principle everything could be done with
  read and write validate 
** separate mailbox from data databases at all times
- same reason as for the semipublic databases. Security. New signups have no
 right to anything initially, so they shouldn't be able to write to or read
 from app data databases, not even secured through vuds and vrds and
 roles/names, in case of bugs or misconfiguration perhaps. A new signup has no
 roles and is not added to any database by name, so cannot not access app
 databases by default, not through configuration, it's safer and easier,
 rights have to be granted, not withheld.
- no filtering needed to separate comms from data, no possibility of muddling
  of either database. When the data db is muddled this might propagate through
  the system if reps are not properly setup.
- but client needs to listen to two databases sometimes, but only needs to
  listen to mailbox when interested, for instance when it has sent a request
  and it wants confirmation. 
** one database per user, combining data and mail, sometimes two
- only one connection.
- but sometimes a user gets data from a group database but needs to have
  connection for individual msgs at all times so would have permanent 2
  connection going then.
** separate app logic and housekeeping logic
vuds and vrds are going to have a lot of app logic in them, like to keep this
logic separate from housekeeping/basic access logic 
  

* Databases
** reception
  
 This database is publicly writable. Through the use of validate_doc_update one
 can ensure only certain types of documents get written. For instance attachment
 can be blocked, or overly big field values etc. Any message written get picked
 up =cape= (through the changes api) and immediately deleted from the
 =reception= database. This database is supposed to be write-only. At the moment
 this is not possible using CouchDB only (version 1.6), however a simple proxy
 server in front of the public face of CouchDB can fix this by only allowing
 POST and PUT requests to this database. A fork of CouchDB called [[https://github.com/rcouch/rcouch/wiki][rcouch]] does
 have write-only databases and read validation support. It's supposed to [[https://blogs.apache.org/couchdb/entry/merging_rcouch][merge]]
 with CouchDB 'soon'.

** public

 This is not publicly writable, however anybody can read from it. It is used to
 transmit little messages of success or error to various requests made through
 =reception=. 
 
 When messages to =reception= include a 'callback' id, the client sending the
 message can receive the feedback from =cape= through the =public= database by
 listening to changes in this database, but filtered by this callback id. This
 filtering happens on the server, so the only time the client is contacted is
 when a relevant message gets written to =public= by =cape=. Of course a client
 can listen to all changes, and depending on how many people are trying to sign
 up or are going through 'forgot pwd' procedures, quite a few messages can get
 read. The messages (docs) themselves contain nothing but a callback id and a
 field with a string containing information such as 'password updated', or
 'email missing' or 'email sent' or 'too short password' etc. This is a security
 leak, but very big.
 
** temp
  
  Internal database used by =cape= to remember messages posted to =reception=
  so the proper follow up action can be taken in response to further messages
  from the same client.
  
** private_[email]_[hash-of-email]
  Email is normalized so couchb accepts the name. The hash is there to
  guarantee uniqueness nonetheless. 
  secObj = { admins: { names:[], roles:[]}, 
  members: { names: ["<email>"], roles: ["_role1", "_role2"]} }
  The underscored roles are there so that 
** shared_[access_object_hash]
   This is represented by a user in _users. The secObj is in there, so the
   database can be recreated, also the owner of the docs, that is, who has
   shared this set of docs with others using this shared database. Also if
   other users can remove/add roles and names to/from the secObj of this database.
  secObj = { admins: { names:[], roles:[]}, 
  members: { names: ["email1", "email2" ], roles: ["role1", "role1"]} }
  Users with email1 and email2 and all users who have role1 and role2 can access
  this database. They can ask cape which databases they can access, cape knows
  because it can parse the _users database.
** stats
session tracker agent can send stats or log messages etc.
* agents
** sessiontracker    
  deals with messages such as signedin, loggingout and ping, because these messages
  are reliable to a point only, a best guess should be made. For instance a
  client can send pings when activity is detected. But if client logs in and
  only listens to changes sessiontracker doesn't know about them. Session
  tracker could listen to changes on client's databases so it knows when to
  write to it. Or other agents could notify it when they notice activity from a
  client. Or it could actively monitor/tail couch's log. At debug levels auth
  events get logged. You would have to parse it and make sense of it.
* implement:
** trello
everyone their own multiple todo lists, organized by board
share by the board/list/item, share ro or rw
when owned/shared and writable any edits should propogate and magically change
at other peoples boards/lists/items
when owned/shared should be  able to share further when allowed
when client shares something it should send msg/notification to other user it
shares with.
** shop
** wiki
** social network 
** inventory 

** gregs's project
  people have roles such as family, circle, extended fammily, service provider
  etc every doc has an access level, chosen from different set dependent on type
  of doc.  different types of docs have different set of access levels then for
  a certain doc type lets say medical info (taxonomy): set for every role
  whether they can create/update/delete read a document of this type.  So in
  other words, every doc has a type_access-level access role assigned, then in
  the reps access scenario (one database per role/id), every db gets assigned
  the proper roles. Same strategy for the cud, if some with the database's role
  writes, check the secObj of the db whether they can cud.
  So Greg's config-access table is modified by modifying the secObj of every db
  that represents a role.

** edge

   
   
* TODO

** disallow singupt tom@email.com and Tom@email.com
Record and use the email local capitalisations as sgned up, but don't allow
different capitalisations of local to sign up.
** monitor does no work right now
  is called but work function is empty 
** follow should stop listening when no response
   because the browser hangs/eats up all memory
** rewrite backend in clojure
** rewrite/write frontend in clojurescript  
** client should stop listening when error, since it locks up the browser/computer 
   just try again now and again, or on the request of user instead.
** make sure deletion of public and temp is self-repairing  
** on signup create user mailbox  
  monitor existence (for every user, infrequent, once per 5 minutes or rarer),
  subscribe to db changes, react to nomailbox msg in reception from user,
  username: is added and from: is added to msg, and ack send to public
  (ok/error); Client should try periodically when mailbox is not there, to see
  if it's back
** validate_read_doc:
access based on user role, doc type and taxonomy.  
** send inter user message:
- send msg to mailbox > instant:true/false from:username (validated by to be
username vud) msg:mail to:otherusername content:"bla bla" 
- gets replicated to postoffice, or postoffice listens to changes in every mailbox?  
- postoffice puts msg in recipient's (:to) mailbox
- if instant=true, remove from mailboxes after timeout, otherwise leave in
  place?
** make sure log messages are an independant stream to be
picked up a separate process!!!!  Both from cape backend and frontend.
** how about tests?
- clojurescript repl to automate tests   
- automated browser testing?  
** how about csrf?
Several things have to happen for cross-site request forgery to succeed:
- The attacker must target either a site that doesn't check the referrer header
  (which is common) or a victim with a browser or plugin that allows referer
  spoofing (which is rare).
- The attacker must find a form submission at the target site, or a URL that has
  side effects, that does something (e.g., transfers money, or changes the
  victim's e-mail address or password).
- The attacker must determine the right values for all the forms or URL inputs;
  if any of them are required to be secret authentication values or IDs that the
  attacker can't guess, the attack will fail.
- The attacker must lure the victim to a Web page with malicious code while the
victim is logged into the target site.

>> at least set the proper cors origin!!!!
>> only vulnerability are POST requests? 
http://en.wikipedia.org/wiki/Cross-site_request_forgery

** watch out for xss!!!
sanitize anything that can get rendered by the browser, 
for instance an agent can rewrite docs, or vud can disallow unescaped output 
https://www.npmjs.org/package/validator
also the app has to not allow to render unescaped data!!!!
Apply csp!!!!
http://www.html5rocks.com/en/tutorials/security/content-security-policy/

** if cb in mailbox is called with error auto fix it!!!
** how to deal with backlog in mailboxes? 
** make reception unreadable by adding proxy or use rcouch
** test starting from scratch, empty database 
** passwordless login  
  this just needs adaption on the client side 
** somebody should be monitoring the agents and restart them !!! 
** do cape agents needs less than full _admin rights?  
  But nobody else can create databases though.  
** formalize error msgs!!! 
  just strings for now 
** enable https for couch
** restart listeners to mailboxes when stopped
** setup logrotate for couchdb!! 
   http://wiki.apache.org/couchdb/Installing_on_Ubuntu
   http://java.dzone.com/articles/how-install-couch-db-15-ubuntu
** couchdb is timing out the reps trying!!!
** how to setup frontend cape.js?
With modules? So then we need bb-server!
But source needs to be in cape
Or just test in node, just don't use node dependencies,
and also test in test-cape now and then, to see if it has the same results?

** setup basic comm between front and backend 
** hide follow under vouchdb.changes in the node version of vouchdb  
** replace jquery dependency in node and browser in vouchdb!!
replace vouch_couch with vouch_cradle on node
or factor out jquery on node   
or replace with request:
https://github.com/iriscouch/browser-request/

** have env.js get is vars from the ENV
  now it's hardbaked, but under version source control 

** DONE implement wipe all designdocs in rean.js  
  for that matter, wipe all cape databases as well, and all users and all
  replications
  
** DONE lock down npm dependencies of 3rd party libs!!
   run npm shrinkwrap to find out version numbers
** DONE store mandril email password in ENV 
** DONE add from/to fields to msgs  
** DONE all jobs running permanently should be agents!!
** DONE vouch_couch creates a session but
   sessions expire, admin:irma needs to be baked into all requests
** DONE enable cors for couchdb when initing
** DONE unique email/username when signing up!!! 
** DONE lock down public from writing, is read only   
** DONE set filter in public for callback  
** DONE set view to list names in _users
** DONE lock down temp db from writing/reading 
** DONE put a validate_doc_update on the mailboxes!!  
otherwise browser can't access it!!!
** DONE mailboxes need to be locked down:
set security object
add appropriate doc_validate_update
   

* research
  http://wiki.apache.org/couchdb/PerDocumentAuthorization
** other logins than couchdb native
1. use couchdb pluggable auth mechanisms
2. put nodejs in front, forward to couch, but use password.js or something to
   authenticate via github/facebook/google/twitter etc   
* resources
 https://github.com/etrepum/couchperuser  
 https://github.com/pegli/couchdb-dbperuser-provisioning/blob/master/lib/provision.js  
 https://github.com/flatiron/cradle
 https://www.npmjs.org/package/couchdb-expired
 https://www.npmjs.org/package/couchdb-tools
 
 using continuous for changes feed and has email queue example in tests:
 https://github.com/mikeal/dbemitter

 Convert an NPM package command-line program into a web page:
 https://github.com/iriscouch/browser_bin
 
 Detect security issues, large or small, in a CouchDB server
 https://github.com/iriscouch/audit_couchdb
 
* pouchdb considerations
** replication persistence
They should never stop!!!
https://github.com/HubSpot/offline/
Automatically display online/offline indication to your users. #hubspot-open-source
http://pouchdb.com/api.html#replication
https://groups.google.com/forum/#!topic/pouchdb/9ywFZ6ceqNc
https://www.bountysource.com/issues/1034011-persistent-replications?utm_campaign=plugin&utm_content=tracker%2F52197&utm_medium=issues&utm_source=github
** replication size
How much to replicate and how to dump old data?
Without then deleting the docs on the server when removed from client in a
synced replication?

* good to know
  
** couchdb needs to serve pages.. 
  just load as attachment to doc and link to it as database/doc/attachment.html
** start a coucbd instance
   install build-couchdb, follow instructions in its readme
   https://github.com/jhs/build-couchdb
   see bin/couchdb and bin/couch.ini for starting it

** using follow on node, and vouchdb.changes on browser.
  longpoll on browser (vouchdb.changes), or perhaps event-source? 
  http://couchdb.readthedocs.org/en/latest/api/database/changes.html#event-source
   
** install  and start docker with couchdb
Install docker on Ubuntu 13.10 Saucy:
 https://docs.docker.com/installation/ubuntulinux/#ubuntu-raring-1304-and-saucy-1310-64-bit
Mint needs some extra packages, see bottom of page 
https://registry.hub.docker.com/u/klaemo/couchdb/
Start docker:
docker run -d -p 5984:5984 --name couchdb klaemo/couchdb

** reverse proxy for haproxy
https://github.com/foosel/OctoPrint/wiki/Reverse-proxy-configuration-examples

ction wait(couchdb, db, cb) {
    
    function change(error, change) {
        if(!error) {
            log(change);
            log(db + ": Change " + change.seq + " has " + Object.keys(change.doc).length + " fields");
        }
        else log._e(error);
    }

    var config = {
        db: 'http://' + couchdb.admin + ':' + couchdb.pwd + '@'  +
            couchdb.url + '/' + db,
        include_docs: true,
        since: "now"
    };
        log(config);
   l
** persona:
Add this script or download and include -that- <script
src="https://login.persona.org/include.js"></script> Include persona-buttons.css
Include cookie.js Include persona.js with the initPersona function Call it
before the app starts.  Add these functions to a controller:

    $scope.signout = function($event) { $event.preventDefault();
        console.log('Logging out'); navigator.id.logout();
        
    };
    
    $scope.signin = function($event) { $event.preventDefault();
        console.log('Logging in'); navigator.id.request(); };
    
Have this html snippet in the controller's scope somewhere: <div ng-show="true">
     <a ng-hide="signedIn" href="#" class="persona-button blue"
     ng-click="signin($event)"><span>Sign in</span></a> <a ng-show="signedIn"
     href="#" class="persona-button blue" ng-click="signout($event)"><span>Sign
     out</span></a> </div>
     
Add this to the server configuration to turn sessions on: ,sessions: { expires:
    30*24*60*60 //one month } Add the right emails to authorized_emails.js
    exports.list = [ 'michieljoris@gmail.com' ];

Add this to server.js ,signin = require("./signin.js") ,signout =
require("./signout.js") Add this to the post handlers ,"/signin": signin
,"/signout": signout After successfull signin $scope.signedIn is the user's
email address
	


* doing

** script to start/reset rcouch
** clean up databases reception, temp and public
   reception: should stay clean, but check periodically and if there's more than n
   docs, shut it down for writing by adding a role or name, wipe it, and make it
   accessible again
- temp: all docs are time stamped, periodically clean out
- public
  timestamp them and periodically clean out
  
  
   
 curl -X PUT http://localhost:5984/_config/couch_http_auth/public_fields -H
 "Content-Type: application/json" -d '"name"' -u admin
asdfa
 
